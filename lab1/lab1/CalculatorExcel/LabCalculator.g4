grammar LabCalculator;/**	PARSER RULES */compileUnit : logicExpression EOF ;expression:    expression OP_MOD expression   #ModOperand  | expression OP_DIV expression   #DivOperand  | expression OP_MUL expression   #MulOperand  | expression OP_ADD expression   #AddOperand  | expression OP_SUB expression   #SubOperand  | OP_ADD expression              #UnaryPlus  | OP_SUB expression              #UnaryMinus  | atom                           #AtomExpr;logicExpression:    left=logicExpression op=OP_OR right=logicExpression     #OrExpr    | left=logicExpression op=OP_AND right=logicExpression    #AndExpr    | op=OP_NOT expr=logicExpression                          #NotExpr	| comparison                                              #CompareExpr	| BOOL                                                    #BoolExpr	| LPAREN logicExpression RPAREN                           #ParenthesizedExpr;comparison    : left=expression op=(OP_EQUAL | OP_LESS | OP_GREATER) right=expression ;operand: 	LPAREN expression RPAREN                      #ParenthesizedOperand	| (OP_ADD | OP_SUB)? atom                     #UnaryOperand	| operand (OP_MOD | OP_DIV) operand           #ModDivOperand	;atom:    NUMBER                          #AtomNumber	| IDENTIFIER                      #AtomIdentifier	| BOOL                            #AtomBool	| LPAREN expression RPAREN        #AtomParenthesized	;/**	LEXER RULES */// Variant 60// 2OP_MOD : 'mod' ;OP_DIV : 'div' ;// 3OP_ADD : '+' ;OP_SUB : '-' ;// 8OP_EQUAL   : '=' ;OP_LESS    : '<' ;OP_GREATER : '>' ;// 10OP_NOT : 'not' ;// 11OP_OR  : 'or' ;OP_AND : 'and' ;BOOL : 'true' | 'false' ;IDENTIFIER : [a-zA-Z_] [a-zA-Z_0-9]* ;NUMBER : [0-9]+ ('.' [0-9]+)? ;LPAREN : '(' ;RPAREN : ')' ;WS : [ \t\r\n]+ -> skip ;